@startuml classes_orchestrator
set namespaceSeparator none
class "DDQNScheduler" as orchestrator.DDQN_scheduler.DDQNScheduler {
  action_size : int
  config : dict
  memory : deque
  model
  node_controller
  schedule_history : list
  state_size : int
  target_model
  update_counter : int
  update_target_frequency : int
  act(state)
  calculate_score(state)
  get_schedule_history()
  parse_cpu(cpu_str)
  parse_gpu(gpu_str)
  parse_memory(mem_str)
  predict(state)
  remember(state, action, reward, next_state, done)
  replay()
  save_schedule_history(file_path)
  schedule_pod(pod)
  select_best_node(states)
  train_model(state, target_f)
  update_target_network()
}
class "Kube_Scheduler" as orchestrator.kube_scheduler.Kube_Scheduler {
  node_controller : NodeController
  calculate_score(node)
  filter_nodes(required_resources)
  prioritize_nodes(available_nodes)
  schedule_pod(pod_name: str, required_resources)
}
class "Kube_Scheduler_Plus" as orchestrator.kube_scheduler_plus.Kube_Scheduler_Plus {
  node_controller : NodeController
  schedule_history : list
  weights : dict
  calculate_score(node)
  filter_nodes(required_resources)
  get_schedule_history()
  parse_cpu(cpu_str)
  parse_gpu(gpu_str)
  parse_memory(mem_str)
  prioritize_nodes(available_nodes)
  save_schedule_history(file_path)
  schedule_pod(pod)
}
class "Scheduler" as orchestrator.scheduler_random.Scheduler {
  nodes
  schedule_container(container_name: str)
}
class "WorkloadController" as orchestrator.workload_controller.WorkloadController {
  manage_workload(container_name: str)
}
@enduml
